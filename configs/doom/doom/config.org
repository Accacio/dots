#+PROPERTY: header-args :comments yes

* General settings
#+begin_src emacs-lisp
(setq user-full-name "Rafael Accácio Nogueira"
      user-mail-address "rafael.accacio.nogueira@gmail.com")
#+end_src

#+begin_src emacs-lisp
(setq search-whitespace-regexp ".*?")

(show-smartparens-global-mode 1)

(let ((langs '("american" "fr_FR" "pt_BR")))
      (setq lang-ring (make-ring (length langs)))
      (dolist (elem langs) (ring-insert lang-ring elem)))
(let ((dics '("american-english" "french" "portuguese")))
      (setq dic-ring (make-ring (length dics)))
      (dolist (elem dics) (ring-insert dic-ring elem)))

  (defun cycle-ispell-languages ()
      (interactive)
      (let (
            (lang (ring-ref lang-ring -1))
            (dic (ring-ref dic-ring -1))
            )
        (ring-insert lang-ring lang)
        (ring-insert dic-ring dic)
        (ispell-change-dictionary lang)
        (setq ispell-complete-word-dict (concat "/usr/share/dict/" dic))
        ))
(global-set-key [f6] 'cycle-ispell-languages)

(add-hook 'after-save-hook
          'executable-make-buffer-file-executable-if-script-p)
#+end_src
** git
#+begin_src emacs-lisp
(use-package! magit-todos
  :after magit
  :config
  (setq magit-todos-keyword-suffix "\\(?:([^)]+)\\)?:?") ; make colon optional
  (setq magit-todos-keywords-list '("TODO" "WAITING" "FIXME" "REVIEW" "HACK" "DEPRECATED" "BUG" "XXX"))
  (define-key magit-todos-section-map "j" nil)
  (map! :leader
        (:prefix-map ("p" . "project")
         :desc "List project todos"           "t" #'magit-todos-list
         )
        )
  (when (modulep! :editor evil +everywhere)
    (map! :leader
          (:prefix-map ("p" . "project")
           :desc "List project todos"           "t" #'magit-todos-list
           )
          )

    )
  )
#+end_src

* Completion
** ivy
#+begin_src emacs-lisp
(setq ivy-use-selectable-prompt t)

;; Solves not a directory for ivy
(defun ivy-rich--switch-buffer-directory! (orig-fun &rest args)
    (cl-letf (((symbol-function 'directory-file-name) #'file-name-directory))
      (apply orig-fun args)))
  (advice-add 'ivy-rich--switch-buffer-directory :around #'ivy-rich--switch-buffer-directory!)

(after! ivy-bibtex
(advice-add #'helpful--buffer :filter-return
  (lambda (buf)
    (with-current-buffer buf (setq-local list-buffers-directory nil))
    buf))
(defun bibtex-completion-insert-doi (keys)
  "Open the URL or DOI associated with entries in KEYS in a browser."
  (dolist (key keys)
    (let* ((entry (bibtex-completion-get-entry key))
           (doi (bibtex-completion-get-value "doi" entry))
           )
      (insert (format "doi.org/%s" doi))
      )))

(ivy-bibtex-ivify-action bibtex-completion-insert-doi ivy-bibtex-insert-doi)

  (ivy-set-actions
   'ivy-bibtex
   '(("p" ivy-bibtex-open-pdf "Open PDF file (if present)" ivy-bibtex-open-pdf)
     ("u" ivy-bibtex-open-url-or-doi "Open URL or DOI in browser" ivy-bibtex-open-url-or-doi)
     ("c" ivy-bibtex-insert-citation "Insert citation" ivy-bibtex-insert-citation)
     ("d" ivy-bibtex-insert-doi "Insert doi" ivy-bibtex-insert-doi)
     ("r" ivy-bibtex-insert-reference "Insert reference" ivy-bibtex-insert-reference)
     ("k" ivy-bibtex-insert-key "Insert BibTeX key" ivy-bibtex-insert-key)
     ("b" ivy-bibtex-insert-bibtex "Insert BibTeX entry" ivy-bibtex-insert-bibtex)
     ("a" ivy-bibtex-add-PDF-attachment "Attach PDF to email" ivy-bibtex-add-PDF-attachment)
     ("e" ivy-bibtex-edit-notes "Edit notes" ivy-bibtex-edit-notes)
     ("s" ivy-bibtex-show-entry "Show entry" ivy-bibtex-show-entry)
     ("l" ivy-bibtex-add-pdf-to-library "Add PDF to library" ivy-bibtex-add-pdf-to-library)
     ("f" (lambda (_candidate) (ivy-bibtex-fallback ivy-text)) "Fallback options")))
  )
#+end_src
* UI
** Theme/Visuals
#+begin_src emacs-lisp
;; There are two ways to load a theme. Both assume the theme is installed and
;; available. You can either set `doom-theme' or manually load a theme with the
;; `load-theme' function.
(setq doom-theme 'doom-nord)
;; (setq doom-font (font-spec :family "monospace" :size 14))
;; (setq doom-font (font-spec :family "Glass TTY VT220" :size 20))
;; (setq doom-font (font-spec :family "Source Code Pro" :size 16))
(setq doom-font (font-spec :family "Roboto Mono" :size 16))
;; (setq doom-font (font-spec :family "Fira Code" :size 16))


(defun toggle-transparency ()
  (interactive)
  (let ((alpha (frame-parameter nil 'alpha)))
    (set-frame-parameter
     nil 'alpha
     (if (eql (cond ((numberp alpha) alpha)
                    ((numberp (cdr alpha)) (cdr alpha))
                    ;; Also handle undocumented (<active> <inactive>) form.
                    ((numberp (cadr alpha)) (cadr alpha)))
              100)
         '(95 . 80) '(100 . 100)))))

(map! :leader
      (:prefix-map ("t" . "toggle")
       :desc "Transparency"                 "T" 'toggle-transparency))

(setq global-hl-line-modes nil)

(setq display-line-numbers-type 'relative)
(custom-set-faces!
  '(line-number :foreground "#A3BE8C")
  '(line-number-current-line :foreground "#EBCB8B")
  )
#+end_src
* Editor
** emails
- use mail-mode with neomutt buffers
#+begin_src emacs-lisp
(after! core
(setq auto-mode-alist (delete '("mutt" . mail-mode) auto-mode-alist))
(add-to-list 'auto-mode-alist '("/tmp/neomutt" . mail-mode))
)
#+end_src
** Rotate text
#+begin_src emacs-lisp
(after! rotate-text
  :config
  (pushnew! rotate-text-words '("before" "after"))
  (pushnew! rotate-text-words '("horizontal" "vertical"))
  (pushnew! rotate-text-words '("increase" "decrease"))
  (pushnew! rotate-text-words '("top" "bottom"))
  (pushnew! rotate-text-words '("left" "right"))
  (pushnew! rotate-text-words '("up" "down"))
  (pushnew! rotate-text-words '("on" "off"))
  (set-rotate-patterns! 'c-mode
    :words '(("float" "double")
             ))
  (set-rotate-patterns! 'c++-mode
    :words '(("float" "double")
             ("vector" "matrix")))
  )
#+end_src
** writegood
#+begin_src emacs-lisp
(after! writegood-mode
  :config
  (set 'writegood-duplicates-font-lock-keywords-regexp
  "\\b\\([[:alpha:]]+\\)\\([[:space:]]\\|\\s<\\|\\s>\\)+\\1\\b"
  )
)
#+end_src

* Lang
** Remote lsp-mode
#+begin_src emacs-lisp
(after! lsp-mode
  (progn
    (lsp-register-client
     (make-lsp-client :new-connection (lsp-tramp-connection "clangd")
                      :major-modes '(c-mode c++-mode)
                      :remote? t
                      :server-id 'clangd-remote)))
  )
(after! projectile
(setq projectile-generic-command "fd . -0 --type f --color=never")
(setq projectile-git-fd-args "-H -0 -E .git -tf --color=never")
)
#+end_src

** org
- use greek letters on org-mode sections
#+begin_src emacs-lisp
(after! org-modern
(setq org-modern-replace-stars "αβγδεζηθικλμνξοπρστυφχψω")
(setq org-modern-star 'replace)
)
#+end_src
- change ellipsis symbol
#+begin_src emacs-lisp
(setq org-ellipsis " ▼") ;;▼ ⤵
#+end_src
- use python3
#+begin_src emacs-lisp
(setq org-babel-python-command "python3")
#+end_src

#+begin_src emacs-lisp
(after! org
  (setq +latex-viewers '(skim zathura evince sumatrapdf okular pdf-tools))
  (require 'ox-beamer)
  (setq org-latex-listings 'minted)
(setq org-latex-pdf-process
      '("pdflatex -shell-escape -interaction nonstopmode -output-directory %o %f"
        "pdflatex -shell-escape -interaction nonstopmode -output-directory %o %f"
        "pdflatex -shell-escape -interaction nonstopmode -output-directory %o %f"))
  (setq org-link-context-for-files t)
(setq org-latex-default-packages-alist
  '(("AUTO" "inputenc"  t ("pdflatex"))
    ("T1"   "fontenc"   t ("pdflatex"))
    (""     "graphicx"  t)
    (""     "longtable" nil)
    (""     "booktabs" t)
    (""     "wrapfig"   nil)
    (""     "rotating"  nil)
    ("normalem" "ulem"  t)
    (""     "amsmath"   t)
    (""     "fdsymbol"   t)
    (""     "tikz"   t)
    ;; (""     "amssymb"   t)
    (""     "capt-of"   nil)
    (""     "hyperref"  nil))
)
(setq org-latex-classes
      '(("article" "\\documentclass[11pt]{article}"
  ("\\section{%s}" . "\\section*{%s}")
  ("\\subsection{%s}" . "\\subsection*{%s}")
  ("\\subsubsection{%s}" . "\\subsubsection*{%s}")
  ("\\paragraph{%s}" . "\\paragraph*{%s}")
  ("\\subparagraph{%s}" . "\\subparagraph*{%s}"))
 ("report" "\\documentclass[11pt]{report}"
  ("\\part{%s}" . "\\part*{%s}")
  ("\\chapter{%s}" . "\\chapter*{%s}")
  ("\\section{%s}" . "\\section*{%s}")
  ("\\subsection{%s}" . "\\subsection*{%s}")
  ("\\subsubsection{%s}" . "\\subsubsection*{%s}"))
 ("book" "\\documentclass[11pt]{book}"
  ("\\part{%s}" . "\\part*{%s}")
  ("\\chapter{%s}" . "\\chapter*{%s}")
  ("\\section{%s}" . "\\section*{%s}")
  ("\\subsection{%s}" . "\\subsection*{%s}")
  ("\\subsubsection{%s}" . "\\subsubsection*{%s}"))
 ("beamer" "\\documentclass{beamer}"
  ("\\section{%s}" . "\\section*{%s}")
  ("\\subsection{%s}" . "\\subsection*{%s}")
  ("\\subsubsection{%s}" . "\\subsubsection*{%s}")
  ("\\paragraph{%s}" . "\\paragraph*{%s}")
  ("\\subparagraph{%s}" . "\\subparagraph*{%s}"))
 ("neocampus" "\\documentclass{neocampus}"
  ("\\section{%s}" . "\\section*{%s}")
  ("\\subsection{%s}" . "\\subsection*{%s}")
  ("\\subsubsection{%s}" . "\\subsubsection*{%s}")
  ("\\paragraph{%s}" . "\\paragraph*{%s}")
  ("\\subparagraph{%s}" . "\\subparagraph*{%s}"))
 )
      )
(setq org-format-latex-header "\\documentclass{article}
\\usepackage[usenames]{color}
\[DEFAULT-PACKAGES]
\[PACKAGES]
\\pagestyle{empty}             % do not remove
% The settings below are copied from fullpage.sty
\\DeclareSymbolFontAlphabet{\\mathnormal}{letters}
\\setlength{\\textwidth}{\\paperwidth}
\\addtolength{\\textwidth}{-3cm}
\\setlength{\\oddsidemargin}{1.5cm}
\\addtolength{\\oddsidemargin}{-2.54cm}
\\setlength{\\evensidemargin}{\\oddsidemargin}
\\setlength{\\textheight}{\\paperheight}
\\addtolength{\\textheight}{-\\headheight}
\\addtolength{\\textheight}{-\\headsep}
\\addtolength{\\textheight}{-\\footskip}
\\addtolength{\\textheight}{-3cm}
\\setlength{\\topmargin}{1.5cm}
\\addtolength{\\topmargin}{-2.54cm}
\\usetikzlibrary{perspective}
\\newcommand{\\N}{\\mathbb{N}}
\\newcommand{\\Z}{\\mathbb{Z}}
\\newcommand{\\Q}{\\mathbb{Q}}
\\newcommand{\\R}{\\mathbb{R}}
\\newcommand{\\C}{\\mathbb{C}}
\\newcommand{\\T}{^{\\mathrm{T}}}
\\newcommand{\\1}{\\mathbf{1}}
\\newcommand{\\0}{\\mathbf{0}}
\\newcommand{\\set}{\\mathcal}
\\newcommand{\\card}[1]{n_{#1}}
\\newcommand{\\abs}[1]{\\left\\lvert#1\\right\\rvert}
\\newcommand{\\norm}[1]{\\left\\lVert#1\\right\\rVert}
\\renewcommand{\\vec}[1]{\\boldsymbol{#1}}
\\newcommand{\\setbuild}[2]{\\{#1\\mid#2\\}}
\\newcommand{\\seq}[2][n]{\\lbrace #2_{0},\\ldots,\\,#2_{#1} \\rbrace}
\\newcommand{\\hadamard}[2]{#1\\circ #2}
\\newcommand{\\kron}[2]{#1\\otimes#2}
\\newcommand{\\symmetric}{\\mathbb{S}}
\\newcommand{\\semidefpos}{\\mathbb{S}_{+}}
\\newcommand{\\defpos}{\\mathbb{S}_{++}}
\\newcommand{\\elem}[2][1]{{#2}_{(#1)}}
\\newcommand{\\zonotope}{\\meddiamond}
\\newcommand{\\czonotope}{\\diamondvert}
\\newcommand{\\interval}{\\medsquare}
\\renewcommand{\\implies}{\\Rightarrow}
\\renewcommand{\\iff}{\\Leftrightarrow}
\\newcommand{\\argmax}{\\mathop{\\arg\\!\\max}}
\\newcommand{\\argmin}{\\mathop{\\arg\\!\\min}}
\\newcommand{\\maximize}{\\mathop{\\textrm{maximize}}}
\\newcommand{\\interior}{\\mathop{\\textrm{int}}}
\\newcommand{\\minimize}{\\mathop{\\textrm{minimize}}}
\\newcommand{\\minimiser}{\\mathop{\\textrm{minimiser}}}
\\newcommand{\\collection}[1]{\\set{#1}\\!\\!\\raisebox{-2pt}{$\\set{#1}$}\\!\\!\\set{#1}}
\\newcommand{\\maximiser}{\\mathop{\\textrm{maximiser}}}
\\renewcommand{\\epsilon}{\\varepsilon}
\\renewcommand{\\phi}{\\varphi}
")


;; (add-to-list 'org-preview-latex-process-alist '(convert :programs ("latex" "convert")
                                                               ;; :description "pdf > png"
                                                               ;; :message "you need to install the programs: latex and graphicsmagick"
                                                               ;; :use-xcolor t
                                                               ;; :image-input-type "pdf"
                                                               ;; :image-output-type "png"
                                                               ;; :image-size-adjust (1.0 . 1.0)
                                                               ;; :latex-compiler ("pdflatex -interaction nonstopmode -output-directory %o %f")
                                                               ;; :image-converter ("convert -density %D -trim -antialias %f -quality 100 %O")))
;; (setq org-preview-latex-process-alist '())
;; This command sets 'graphicsmagick' process for LaTeX previews in org-mode.
;; (setq org-preview-latex-default-process 'convert)
(setq org-preview-latex-default-process 'dvipng)
(add-hook 'org-mode-hook
          (lambda () (evil-tex-mode))
)

(setq org-plantuml-jar-path "~/bin/plantuml.jar")

;; suppress org-mode bug
(setq warning-suppress-types (append warning-suppress-types '((org-element-cache))))
)
#+end_src


** julia
#+begin_src emacs-lisp
(after! julia-mode
  (add-hook! 'julia-mode-hook
    (setq-local lsp-enable-folding t
                lsp-folding-range-limit 100))
  (add-hook! 'julia-mode-hook 'eglot-jl-init)
  )
#+end_src

** python
#+begin_src emacs-lisp
(add-hook 'python-mode-hook
          (lambda ()
            (setq
             imenu-generic-expression
             '(
               ("Cell" "^## \\(.*[A-z].*\\)" 1)
               ("Comment" "#= \\([A-z].*\\)" 1)
               )
             )
            (setq imenu-create-index-function '(lambda () (imenu--generic-function imenu-generic-expression)))
            )
          )
#+end_src
** Matlab
So we can use completion with matlab
#+begin_src emacs-lisp
(defadvice! inhibit-real-only-a (oldfun &rest r)
  "Temporary remove read-only lines in shell buffer"
  :around#'matlab-shell-collect-command-output
  (let ((inhibit-read-only t)) (apply oldfun r)))
(after! org
  )
(add-hook 'matlab-mode-hook
          (lambda ()
            (setq
             imenu-generic-expression
             '(
               ("Cell" "^%% \\(.*[A-z].*\\)" 1)
               ("Comment" "%= \\([A-z].*\\)" 1)
               ("Block" "%== \\([A-z].*\\)" 1)
               )
             )
            (setq imenu-create-index-function '(lambda () (imenu--generic-function imenu-generic-expression)))
            )
          )

(defvar matlab-shell-gud-minor-mode-map
  (let ((km (make-sparse-keymap)))
    (evil-define-key 'normal km "h" 'matlab-shell-gud-mode-help)

    ;; mlgud bindings.
    (evil-define-key 'normal km "\C-cb" 'mlgud-break)
    (evil-define-key 'normal km "\C-cx" 'mlgud-remove)
    (evil-define-key 'normal km "\C-cc" 'mlgud-cont)
    (evil-define-key 'normal km "\C-cs" 'mlgud-step)
    (evil-define-key 'normal km "\C-cn" 'mlgud-next)
    (evil-define-key 'normal km "\C-cf" 'mlgud-finish)
    (evil-define-key 'normal km "\C-cq" 'mlgud-stop-subjob)
    (evil-define-key 'normal km "\C-c<" 'mlgud-up)
    (evil-define-key 'normal km "\C-c>" 'mlgud-down)
    (evil-define-key 'normal km "\C-cw" 'mlg-show-stack)
    (evil-define-key 'normal km "\C-cv" 'mlgud-list-breakpoints)
    (evil-define-key 'normal km "\C-ce" 'matlab-shell-gud-show-symbol-value)

    (evil-define-key 'normal km "\C-x\C-q" 'matlab-shell-gud-mode-edit) ; like toggle-read-only

    km)
  "Keymap used by matlab mode maintainers.")

(define-minor-mode matlab-shell-gud-minor-mode
  "Minor mode activated when `matlab-shell' K>> prompt is active.
This minor mode makes MATLAB buffers read only so simple keystrokes
activate debug commands.  It also enables tooltips to appear when the
mouse hovers over a symbol when debugging.
\\<matlab-shell-gud-minor-mode-map>
Debug commands are:
 \\[matlab-shell-gud-mode-edit]  - Edit file (toggle read-only)
            Allows editing file without causing MATLAB to exit debug mode.
 \\[mlgud-break]        - Add breakpoint (ebstop in FILE at point)
 \\[mlgud-remove]        - Remove breakpoint (ebclear in FILE at point)
 \\[mlgud-list-breakpoints]        - List breakpoints (ebstatus)
 \\[mlgud-step]        - Step (dbstep in)
 \\[mlgud-next]        - Next (dbstep)
 \\[mlgud-finish]        - Finish function (dbstep out)
 \\[mlgud-cont]        - Continue (dbcont)
 \\[matlab-shell-gud-show-symbol-value]        - Evaluate expression
 \\[mlg-show-stack]        - Where am I (ebstack)
 \\[mlgud-stop-subjob]        - Quit (dbquit)"
  nil " MGUD" matlab-shell-gud-minor-mode-map)

(defvar mlg-stack-mode-map
  (let ((km (make-sparse-keymap)))
    (evil-define-key 'normal km [return] 'mlg-stack-choose)
    (evil-define-key 'normal km "q" 'mlg-stack-quit)
    (evil-define-key 'normal km "n" 'mlg-stack-next)
    (evil-define-key 'normal km "p" 'mlg-stack-prev)
    (evil-define-key 'normal km [mouse-2] 'mlg-stack-click)
    (evil-define-key 'normal km [mouse-1] 'mlg-stack-click)
    km)
  "Keymap used in MATLAB stack mode.")

(after! ob-octave

  ;;from https://github.com/karthink/.emacs.d/blob/master/plugins/ob-octave-fix.el
  (defun org-babel-octave-evaluate-session
      (session body result-type &optional matlabp)
    "Evaluate BODY in SESSION."
    (let* ((tmp-file (org-babel-temp-file (if matlabp "matlab-" "octave-")))
           (wait-file (org-babel-temp-file "matlab-emacs-link-wait-signal-"))
           (full-body
            (pcase result-type
              (`output
               (mapconcat
                #'org-babel-chomp
                (list body org-babel-octave-eoe-indicator) "\n"))
              (`value
               (if (and matlabp org-babel-matlab-with-emacs-link)
                   (concat
                    (format org-babel-matlab-emacs-link-wrapper-method
                            body
                            (org-babel-process-file-name tmp-file 'noquote)
                            (org-babel-process-file-name tmp-file 'noquote) wait-file) "\n")
                 (mapconcat
                  #'org-babel-chomp
                  (list (format org-babel-octave-wrapper-method
                                body
                                (org-babel-process-file-name tmp-file 'noquote)
                                (org-babel-process-file-name tmp-file 'noquote))
                        org-babel-octave-eoe-indicator) "\n")))))
           (raw (if (and matlabp org-babel-matlab-with-emacs-link)
                    (save-window-excursion
                      (with-temp-buffer
                        (insert full-body)
                        (write-region "" 'ignored wait-file nil nil nil 'excl)
                        (matlab-shell-run-region (point-min) (point-max))
                        (message "Waiting for Matlab Emacs Link")
                        (while (file-exists-p wait-file) (sit-for 0.01))
                        "")) ;; matlab-shell-run-region doesn't seem to
                  ;; make *matlab* buffer contents easily
                  ;; available, so :results output currently
                  ;; won't work
                  (org-babel-comint-with-output
                      (session
                       (if matlabp
                           org-babel-octave-eoe-indicator
                         org-babel-octave-eoe-output)
                       t full-body)
                    (insert full-body) (comint-send-input nil t)))) results)
      (pcase result-type
        (`value
         (org-babel-octave-import-elisp-from-file tmp-file))
        (`output
         (setq results
               (if matlabp
                   (cdr (reverse (delete "" (mapcar #'org-strip-quotes
                                                    (mapcar #'org-trim raw)))))
                 (cdr (member org-babel-octave-eoe-output
                              (reverse (mapcar #'org-strip-quotes
                                               (mapcar #'org-trim raw)))))))
         ;; This kludge is to remove the input lines from the output. Because of
         ;; the special way that MATLAB processes bulk comint output (the output
         ;; of each line follows that line) the macro
         ;; `org-babel-comint-with-output' cannot remove the echoed commands. The
         ;; following handles this manually, by splitting both the original input
         ;; (`BODY') and full output (`RESULTS') on newlines, comparing them line
         ;; by line and removing all lines in BODY from RESULTS. Note that RESULTS
         ;; is already a list of strings so additional care is needed.
         (if matlabp
             (let* ((body-lines (split-string body "\n+"))
                    (result-lines (flatten-list
                                   (mapcar
                                    (lambda (entry) (reverse (split-string entry "\n")))
                                    results))))
               (mapconcat
                #'identity
                (reverse (cl-remove-if
                          (lambda (line) (member line body-lines))
                          result-lines)) "\n"))
           results))))))
#+end_src

** Bibtex
#+begin_src emacs-lisp

(defun bibtex-completion-format-citation-cite-org (keys)
  "Format ebib references for keys in KEYS."
  (s-join ", "
          (--map (format "cite:%s" it) keys)))

(after! bibtex-completion
  (setcdr (assq 'org-mode bibtex-completion-format-citation-functions) 'bibtex-completion-format-citation-cite-org)
)

(after! bibtex
  (setq bibtex-completion-bibliography '(("~/research/bibliography.bib") ("~/research/thermique_batiment/bibliography.bib"))
        bibtex-completion-library-path '(("~/research/bibliography/") ("~/research/thermique_batiment/files/"))
        bibtex-completion-find-note-functions '(orb-find-note-file)
        ;; bibtex-completion-find-note-functions (list #'bibtex-completion-find-note-multiple-files #'bibtex-completion-find-note-one-file)
        bibtex-completion-pdf-symbol "!"
        bibtex-completion-notes-symbol "n"
        )
  (setq bibtex-completion-display-formats
        '((t             . "${year:4} ${author:36} ${title:50} ${=type=:13} ${=has-pdf=:1}${=has-note=:1} ${readstatus:7} ${ranking:5} ${keywords}")))
  (setq bibtex-completion-additional-search-fields '(tags ranking readstatus keywords))

  (setq bibtex-dialect 'BibTeX)
  ;; (setq bibtex-dialect 'biblatex)
  ;; (defun my-bibtex-autokey-unique (key)
  ;;   "Make a unique version of KEY."
  ;;   (save-excursion
  ;;     (let ((org-ref-bibliography-files (org-ref-find-bibliography))
  ;;           (trykey key)
  ;; 	  (next ?a))
  ;;       (if (org-ref-key-in-file-p trykey (car org-ref-bibliography-files))
  ;;       (while (and
  ;;               (org-ref-key-in-file-p trykey (car org-ref-bibliography-files))
  ;; 		  (<= next ?z))
  ;; 	(setq trykey (concat key (char-to-string next)))
  ;; 	(setq next (1+ next))))
  ;;       trykey))

  (setq bibtex-autokey-year-length 4)
  (setq bibtex-autokey-names 1)
  (setq bibtex-autokey-names-stretch 1)
  (setq bibtex-autokey-additional-names "EtAl")
  (setq bibtex-autokey-name-case-convert-function 'identity)
  (setq bibtex-maintain-sorted-entries 'entry-class)
  ;; (setq bibtex-autokey-before-presentation-function 'my-bibtex-autokey-unique)
  (setq bibtex-autokey-before-presentation-function nil)

  (defun bibtex-autokey-demangle-name (fullname)
    "Get the last part from a well-formed FULLNAME and perform abbreviations."
    (let* (case-fold-search
           (name (cond
                  ((string-match "\\([^,]*\\)[^,]*," fullname)
                        ;; Name is of the form "von Last, First" or
                        ;; "von Last, Jr, First"
                        ;; --> Take the first capital part before the comma
                        (apply 'concat (split-string (match-string 1 fullname) " "))
                        )
                  ;; ((string-match "\\([[:upper:]][^,]*\\)[^,]*," fullname)
                  ;;       ;; Name is of the form "von Last, First" or
                  ;;       ;; "von Last, Jr, First"
                  ;;       ;; --> Take the first capital part before the comma
                  ;;       (match-string 1 fullname))
                       ((string-match "\\([^, ]*\\)," fullname)
                        ;; Strange name: we have a comma, but nothing capital
                        ;; So we accept even lowercase names
                        (match-string 1 fullname))
                       ((string-match "\\(\\<[[:lower:]][^ ]* +\\)+\\([[:upper:]][^ ]*\\)"
                                      fullname)
                        ;; name is of the form "First von Last", "von Last",
                        ;; "First von von Last", or "d'Last"
                        ;; --> take the first capital part after the "von" parts
                        (match-string 2 fullname))
                       ((string-match "\\([^ ]+\\) *\\'" fullname)
                        ;; name is of the form "First Middle Last" or "Last"
                        ;; --> take the last token
                        (match-string 1 fullname))
                       (t (user-error "Name `%s' is incorrectly formed"
                                      fullname)))))
      ;;(funcall bibtex-autokey-name-case-convert-function
               (bibtex-autokey-abbrev name bibtex-autokey-name-length)
       ;;        )
    ))

  (defun bibtex-generate-autokey ()
    (let* ((names (bibtex-autokey-get-names))
           (year (bibtex-autokey-get-year))
           (title (bibtex-autokey-get-title))
           (autokey (concat
                     names
                     ;; (unless (or (equal names "")
                     ;;             (equal title ""))
                     ;;   "_") ;; string to separate names from title
                     ;; title
                     ;; (unless (or (and (equal names "")
                     ;;                  (equal title ""))
                     ;;             (equal year ""))
                     ;;   bibtex-autokey-year-title-separator)
                     year
                     bibtex-autokey-prefix-string ;; optional prefix string
                     )))
      (if bibtex-autokey-before-presentation-function
          (funcall bibtex-autokey-before-presentation-function autokey)
        autokey)))
  )
#+end_src
** LaTeX
To use with overleaf
#+begin_src emacs-lisp
(require 'atomic-chrome)
(after! atomic-chrome
  (atomic-chrome-start-server)
  (setq atomic-chrome-url-major-mode-alist
      '(
        ("overleaf\\.com" . TeX-mode)
        )
      )
  )
#+end_src


* org-roam
#+begin_src emacs-lisp
(require 'org-roam-protocol)
(after! deft
  (defun cf/deft-parse-title (file contents)
      "Parse the given FILE and CONTENTS and determine the title.
    If `deft-use-filename-as-title' is nil, the title is taken to
    be the first non-empty line of the FILE.  Else the base name of the FILE is
    used as title."
      (let ((begin (string-match "^#\\+[tT][iI][tT][lL][eE]: .*$" contents)))
        (if begin
            (string-trim (substring contents begin (match-end 0)) "#\\+[tT][iI][tT][lL][eE]: *" "[\n\t ]+")
          (deft-base-filename file))))
    (advice-add 'deft-parse-title :override #'cf/deft-parse-title)
  (setq deft-directory (file-truename "~/research/notes/")
        deft-strip-title-regexp (concat "\\(?:"
          "^%+" ; line beg with %
          "\\|^#\\+TITLE: *" ; org-mode title
          "\\|^[#* ]+" ; line beg with #, * and/or space
          "\\|-\\*-[[:print:]]+-\\*-" ; -*- .. -*- lines
          "\\|^Title:[\t ]*" ; MultiMarkdown metadata
          "\\|#+" ; line with just # chars
          "$\\)")
        deft-strip-summary-regexp (concat "\\(?:"
          "^%+" ; line beg with %
          "\\|^:PROPERTIES:\n\\(.+\n\\)+:END:\n" ; org-mode title
          "\\|^#\\+TITLE: *" ; org-mode title
          "\\|^[#* ]+" ; line beg with #, * and/or space
          "\\|-\\*-[[:print:]]+-\\*-" ; -*- .. -*- lines
          "\\|^Title:[\t ]*" ; MultiMarkdown metadata
          "\\|#+" ; line with just # chars
          "$\\)")
          deft-separator " ⏹ "
        )
  )

(use-package! websocket
    :after org-roam)
(use-package! org-roam-ui
    :after org-roam ;; or :after org
;;         normally we'd recommend hooking orui after org-roam, but since org-roam does not have
;;         a hookable mode anymore, you're advised to pick something yourself
;;         if you don't care about startup time, use
;;  :hook (after-init . org-roam-ui-mode)
    :config
    (setq org-roam-ui-sync-theme t
          org-roam-ui-follow t
          org-roam-ui-update-on-save t
          org-roam-ui-open-on-start t))

(after! org-roam
  (setq org-roam-directory (file-truename "~/research/notes/"))
  (setq org-roam-capture-templates
        '(
          ("d" "default" plain "%?" :if-new
           (file+head "%<%Y%m%d%H%M%S>-${slug}.org" "#+title: ${title}\n")
           :unnarrowed t)
          ("r" "bibliography reference" plain
           (file "~/.config/doom/ref.org")
           :if-new
           (file+head "references/${citekey}.org" "#+title: ${citekey}\n"))
          ))

  (cl-defmethod org-roam-node-directories ((node org-roam-node))
    (if-let ((dirs (file-name-directory (file-relative-name (org-roam-node-file node) org-roam-directory))))
        (format "%s" (car (reverse (f-split dirs))))
      ""))

  (cl-defmethod org-roam-node-type ((node org-roam-node))
  "Return the TYPE of NODE."
  (condition-case nil
      (file-name-nondirectory
       (directory-file-name
        (file-name-directory
         (file-relative-name (org-roam-node-file node) org-roam-directory))))
    (error "")))

  (cl-defmethod org-roam-node-backlinkscount ((node org-roam-node))
  (let* ((count (caar (org-roam-db-query
                       [:select (funcall count source)
                                :from links
                                :where (= dest $s1)
                                :and (= type "id")]
                       (org-roam-node-id node)))))
    (format "[%d]" count)))

(setq org-roam-node-display-template "📁 ${directories:10} | ${title:50} | ⚡ ${tags}")

(setq org-roam-mode-sections
      '((org-roam-backlinks-section :unique t)
        org-roam-reflinks-section))
(setq org-roam-graph-viewer (executable-find "vivaldi"))
(require 'org-roam-export)
;; (setq org-roam-node-display-template
;;       (concat "${type:15} ${title:*} " (propertize "${tags:10}" 'face 'org-tag)))
  ;; org-roam-db-gc-threshold most-positive-fixnum
  ;; org-roam-db-update-on-save t
  ;; org-id-link-to-org-use-id t)
  )
#+end_src

* Research
#+begin_src emacs-lisp
(use-package! org-roam-bibtex
  :after (org-roam)
  :init
  (org-roam-bibtex-mode)
  :config
   (setq orb-preformat-keywords
   '("citekey" "title" "url" "file" "author-or-editor" "keywords"))
  )
#+end_src
** overleaf
#+begin_src emacs-lisp
(use-package! atomic-chrome
  :defer 3
  :when (display-graphic-p)
  :preface
  (defun +my/atomic-chrome-server-running-p ()
    (cond ((executable-find "lsof")
           (zerop (call-process "lsof" nil nil nil "-i" ":64292")))
          ((executable-find "netstat")  ; Windows
           (zerop (call-process-shell-command "netstat -aon | grep 64292")))))
  ;; (atomic-chrome-edit-mode . +my/atomic-chrome-mode-setup)
  :config
  (progn
    (setq atomic-chrome-buffer-open-style 'full) ;; or frame, split
    (setq atomic-chrome-url-major-mode-alist
          '(("overleaf\\.com"        . tex-mode)
            ))

;;     (defun +my/atomic-chrome-mode-setup ()
;;       (setq header-line-format
;;             (substitute-command-keys
;;              "Edit Chrome text area.  Finish \
;; `\\[atomic-chrome-close-current-buffer]'.")))

    (if (+my/atomic-chrome-server-running-p)
        (message "Can't start atomic-chrome server, because port 64292 is already used")
      (atomic-chrome-start-server))))
#+end_src

* Agenda
#+begin_src emacs-lisp
(after! org
  (setq org-agenda-files (list "inbox.org" "tickler.org" "personal.org" "areas.org" "books_series_films.org" "work.org" "Soheib.org")
        org-directory "~/prive/Dropbox/org/"
        org-id-locations-file  "~/prive/Dropbox/org/.orgids")

  ;; use org-protocol to capture ideas
  ;; javascript:location.href='org-protocol://capture?template=i'+
  ;;       '&url='+encodeURIComponent(window.location.href)+
  ;; '&title='+encodeURIComponent(document.title)+
  ;; '&body='+encodeURIComponent(window.getSelection());
  (setq org-capture-templates
        `(("i" "Inbox" entry  (file "~/prive/Dropbox/org/inbox.org")
           ,(concat "* TODO %?%a\n"
                    ;; ":PROPERTIES:\n"
                    "CREATED: %U\n\n"
                    ;; ":END:\n\n"
                    "%i"))
          ))

  (setq org-agenda-hide-tags-regexp "inbox")
  (setq org-agenda-prefix-format
        '((agenda . " %i %-12:c%?-12t% s")
          (todo   . " ")
          (tags   . " %i %-12:c")
          (search . " %i %-12:c")))

  (setq org-agenda-custom-commands
        '(
          ("g" "Get Things Done (GTD)"
           ((agenda ""
                    ((org-agenda-skip-function
                      '(org-agenda-skip-entry-if 'deadline))
                     (org-deadline-warning-days 0)))
            (tags-todo "inbox"
                       ((org-agenda-prefix-format "  %?-12t% s")
                        (org-agenda-overriding-header "\nInbox\n")))
            (todo "NEXT"
                  (
                   ;; (org-agenda-skip-function
                   ;;  ;; '(org-agenda-skip-entry-if 'deadline)
                   ;;  ;; #'my-org-agenda-skip-all-siblings-but-first
                   ;;    #'my-org-agenda-skip-all-siblings-but-first
                   ;;  )
                   (org-agenda-prefix-format "  %i %-12:c [%e] ")
                   (org-agenda-overriding-header "\nTasks\n")
                   )
                  )
            ;; (agenda nil
            ;;         ((org-agenda-entry-types '(:deadline))
            ;;          (org-agenda-format-date "")
            ;;          (org-deadline-warning-days 7)
            ;;          (org-agenda-skip-function
            ;;           '(org-agenda-skip-entry-if 'notregexp "\\* NEXT"))
            ;;          (org-agenda-overriding-header "\nDeadlines")))
            ))
          ("w" . "Work")
          ("ww" "Work general"
           (
            (tags-todo "+@work+teaching"
                       ((org-agenda-prefix-format "  %?-12t% s")
                        (org-agenda-overriding-header "Teaching\n"))
                       )
            (tags-todo "+@work+building"
                       ((org-agenda-prefix-format "  %?-12t% s")
                        (org-agenda-overriding-header "Building\n"))
                       )
            (tags-todo "+@work+setbased"
                       ((org-agenda-prefix-format "  %?-12t% s")
                        (org-agenda-overriding-header "Set-based methods\n"))
                       )
            (tags-todo "+@work+security"
                       ((org-agenda-prefix-format "  %?-12t% s")
                        (org-agenda-overriding-header "\nSecurity\n"))
                       )
            )
           )
          ;; ("ws" "Soheib"
          ;;  (
          ;;   (tags "+@work+soheib+LEVEL=1"
          ;;         ((org-agenda-prefix-format "  %?-12t% s")
          ;;          (org-agenda-overriding-header "Soheib\n")
          ;;          )
          ;;         )
          ;;   )
          ;;  )
          ("r" "Reading List"
           (
            (tags-todo "+@work+reading_list"
                       ((org-agenda-prefix-format "  %?-12t% s")
                        (org-agenda-overriding-header "Reading List\n"))
                       )
            )
           )
          ("h" "At home" tags-todo "@home"
           ((org-agenda-overriding-header "Home"))
           )
          ))
  ;; from https://dindi.garjola.net/org-agenda-weekly.html
  (setq org-todo-keywords
        (quote (
                (sequence "TODO(t)" "NEXT(n)"
                          "STARTED(s!)" "|" "DONE(d)" "Kill(k)")
                (type "PROJECT(p!)" "|" "DONE_PROJECT(D!)")
                (sequence "WAITING(w@!)" "SOMEDAY(S!)"  "|"
                          "CANCELLED(c@/!)")
                (type "QUESTION(q)" "|" "ANSWERED(A)")
                )))
  (setq hl-todo-keyword-faces
        '(("HOLD" . "#d0bf8f")
          ("TODO" . "#cc9393")
          ("NEXT" . "#dca3a3")
          ;; ("THEM" . "#dc8cc3")
          ;; ("PROG" . "#7cb8bb")
          ("QUESTION" . "#7cb8bb")
          ;; ("DONT" . "#5f7f5f")
          ;; ("FAIL" . "#8c5353")
          ("DONE" . "#afd8af")
          ("NOTE"   . "#d0bf8f")
          ;; ("KLUDGE" . "#d0bf8f")
          ;; ("HACK"   . "#d0bf8f")
          ;; ("TEMP"   . "#d0bf8f")
          ;; ("FIXME"  . "#cc9393")
          ;; ("XXX+"   . "#cc9393")
          )
        )
  (setq org-todo-keyword-faces '(
                                 ("[-]" . +org-todo-active)
                                 ("STRT" . +org-todo-active)
                                 ("STARTED" . +org-todo-active)
                                 ("[?]" . +org-todo-onhold)
                                 ("WAITING" . +org-todo-onhold)
                                 ("PROJECT" . +org-todo-project)
                                 ;; ("NO" . +org-todo-cancel)
                                 ("QUESTION" . magit-signature-error)
                                 ;; ("KILL" . +org-todo-cancel)
                                 )
        )

  (defun accacio/generate-agenda-weekly-review ()
    "Generate the agenda for the weekly review"
    (interactive)
    (let ((span-days 24)
          (offset-past-days 10))
      (message "Generating agenda for %s days starting %s days ago"
               span-days offset-past-days)
      (org-agenda-list nil (- (time-to-days (date-to-time
                                             (current-time-string)))
                              offset-past-days)
                       span-days)
      (org-agenda-log-mode)
      (goto-char (point-min))))

  (setq org-refile-targets
        '(
          ("projects.org" :regexp . "\\(?:\\(?:Note\\|Task\\)s\\)")
          ("Eve.org" :regexp . "\\(?:\\(?:Note\\|Task\\)s\\)")
          ("personal.org" :maxlevel . 1)
          ("work.org" :maxlevel . 2)
          ("these.org" :maxlevel . 1)
          ("tickler.org" :maxlevel . 1)
          ("someday.org" :level . 1)
          ("Soheib.org" :level . 1)
          ("books_series_films.org" :maxlevel . 9)
          )
        )

  ;; from https://emacs.cafe/emacs/orgmode/gtd/2017/06/30/orgmode-gtd.html
  (defun my-org-agenda-skip-all-siblings-but-first ()
    "Skip all but the first non-done entry."
    (let (should-skip-entry)
      (unless (org-current-is-todo)
        (setq should-skip-entry t))
      (save-excursion
        (while (and (not should-skip-entry) (org-goto-sibling t))
          (when (org-current-is-todo)
            (setq should-skip-entry t))))
      (when should-skip-entry
        (or (outline-next-heading)
            (goto-char (point-max))))))

  (defun org-current-is-todo ()
    (string= "TODO" (org-get-todo-state)))
  ;; (setq org-capture-templates
  ;;       '(
  ;;         ("i" "Inbox" entry (file "inbox.org") (concat "* TODO %?\n" " Entered on %U"))
  ;;         ("t" "TODOS" )
  ;;        ("tp" "Personal todo" entry
  ;;         (file+headline "~/org/todo.org" "Inbox")
  ;;         "** TODO %?\n%i\n%a" :prepend t)
  ;;        ("tt" "These todo" entry
  ;;         (file+headline "~/org/todo_these.org" "Inbox")
  ;;         "** TODO %?\n%i\n%a" :prepend t)
  ;;        ("e" "Evelise" entry
  ;;         (file+headline "~/org/Eve.org" "Inbox")
  ;;         "** TODO %?\n%i\n%a" :prepend t)
  ;;        ("p" "Templates for projects")
  ;;        ("pt" "Project-local todo" entry
  ;;         (file+headline +org-capture-project-todo-file "Inbox")
  ;;         "* TODO %?\n%i\n%a" :prepend t)
  ;;        ("pn" "Project-local notes" entry
  ;;         (file+headline +org-capture-project-notes-file "Inbox")
  ;;         "* %U %?\n%i\n%a" :prepend t)
  ;;        ("pc" "Project-local changelog" entry
  ;;         (file+headline +org-capture-project-changelog-file "Unreleased")
  ;;         "* %U %?\n%i\n%a" :prepend t)
  ;;        ("o" "Centralized templates for projects")
  ;;        ("ot" "Project todo" entry #'+org-capture-central-project-todo-file "* TODO %?\n %i\n %a" :heading "Tasks" :prepend nil)
  ;;        ("on" "Project notes" entry #'+org-capture-central-project-notes-file "* %U %?\n %i\n %a" :heading "Notes" :prepend t)
  ;;        ("oc" "Project changelog" entry #'+org-capture-central-project-changelog-file "* %U %?\n %i\n %a" :heading "Changelog" :prepend t)
  ;;        ))
  ;;               '(
  ;;                 ("e" "Evelise" entry (file+headline "~/Dropbox/org/private/Eve.org" "Inbox")
  ;;                  "** TODO %?\n%i%a "
  ;;                  :kill-buffer t)
  ;;                 )
  ;;               ;; org-capture-templates)
  )
#+end_src
* org-noter
#+begin_src emacs-lisp
(use-package! org-noter
  :config
  (setq
   org-noter-pdftools-markup-pointer-color "#B3CE9C"
   org-pdftools-use-isearch-link t
   org-noter-notes-search-path '("~/research/notes/reviews/" "~/research/notes/references/")
   pdf-annot-color-history '("#B3CE9C"
                             "#FBDB9B"
                             "#d08770"
                             "#CF717A"
                             "#000000")
   org-noter-doc-split-fraction '(0.6 . 0.4)
   org-noter-always-create-frame nil
   org-noter-hide-other nil
   org-noter-pdftools-free-pointer-icon "Note"
   org-noter-pdftools-free-pointer-color "red"
   org-noter-kill-frame-at-session-end nil
   )


;; from https://github.com/fuxialexander/org-pdftools/issues/96#issuecomment-1917553385
;; Added patch function
(defun org-noter--check-and-convert-location (location)
  "If the location is an org-noter-pdftools-location, it transforms
it into a (page . height) cons, otherwise it keeps the cons
unaltered"
  (if (org-noter-pdftools--location-p location)
      (cons (org-noter-pdftools--location-page location)
            (org-noter-pdftools--location-height location))
    location))

(defun org-noter-insert-note (&optional toggle-highlight precise-info)
  (interactive "P")
  (org-noter--with-valid-session
   (let* ((ast (org-noter--parse-root)) (contents (org-element-contents ast))
          (window (org-noter--get-notes-window 'force))
          (selected-text (run-hook-with-args-until-success
                          'org-noter-get-selected-text-hook
                          (org-noter--session-doc-mode session)))
          (selected-text-p (> (length selected-text) 0))
          force-new
          (location (org-noter--doc-approx-location (or precise-info 'interactive) (gv-ref force-new)))
          (current-view (org-noter--get-current-view)))

     (let* ((inhibit-quit t)
            (short-selected-text (if (and selected-text-p
                                          (<= (length selected-text) org-noter-max-short-selected-text-length))
                                     selected-text))
            (org-noter-highlight-selected-text (if toggle-highlight (not org-noter-highlight-selected-text)
                                                 org-noter-highlight-selected-text))
            (highlight-location (if org-noter-highlight-selected-text (org-noter--get-highlight-location))))

       (with-local-quit
         (select-frame-set-input-focus (window-frame window))
         (select-window window)

         ;; IMPORTANT(nox): Need to be careful changing the next part, it is a bit
         ;; complicated to get it right...

         (let ((view-info (org-noter--get-view-info current-view location))
               (minibuffer-local-completion-map org-noter--completing-read-keymap)
               collection title note-body existing-note
               (default-title (or short-selected-text
                                  (replace-regexp-in-string (regexp-quote "$p$")
                                                            ;; (org-noter--pretty-print-location-for-title location)
                                                            (org-noter--pretty-print-location-for-title (org-noter--check-and-convert-location location))
                                                            org-noter-default-heading-title)))
               (empty-lines-number (if org-noter-separate-notes-from-heading 2 1)))

           ;; NOTE(phm): prompt for title unless this is a precise note
           (unless precise-info
             ;; construct collection for matching existing notes
             (dolist (note-cons (org-noter--view-info-notes view-info))
               (let ((display (org-element-property :raw-value (car note-cons))))
                 (push (cons display note-cons) collection))))

           (setq collection (nreverse collection)
                 ;; prompt for title (unless no-Q's)
                 title (if org-noter-insert-note-no-questions default-title
                         (completing-read "Note: " collection nil nil nil nil default-title))
                 note-body (if (and selected-text-p
                                    (not (equal title short-selected-text)))
                               selected-text)
                 ;; is this an existing note? skip for precise notes
                 existing-note (unless precise-info (cdr (assoc title collection))))

           (if existing-note
               ;; NOTE(nox): Inserting on an existing note
               (let* ((note (car existing-note))
                      (insert-before-element (cdr existing-note))
                      (has-content
                       (eq (org-element-map (org-element-contents note) org-element-all-elements
                             (lambda (element)
                               (if (org-noter--check-location-property element)
                                   'stop
                                 (not (memq (org-element-type element) '(section property-drawer)))))
                             nil t)
                           t)))
                 (when has-content (setq empty-lines-number 2))
                 (if insert-before-element
                     (goto-char (org-element-property :begin insert-before-element))
                   (goto-char (org-element-property :end note)))

                 (if (org-at-heading-p)
                     (progn
                       (org-N-empty-lines-before-current empty-lines-number)
                       (forward-line -1))
                   (unless (bolp) (insert "\n"))
                   (org-N-empty-lines-before-current (1- empty-lines-number)))

                 (when (and org-noter-insert-selected-text-inside-note note-body)
                   (if short-selected-text
                       (insert "``" note-body "''")
                     (insert "#+BEGIN_QUOTE\n" note-body "\n#+END_QUOTE"))))

             ;; NOTE(nox): Inserting a new note
             (let ((reference-element-cons (org-noter--view-info-reference-for-insertion view-info))
                   level)
               (if reference-element-cons
                   (progn
                     (cond
                      ((eq (car reference-element-cons) 'before)
                       (goto-char (org-element-property :begin (cdr reference-element-cons))))
                      ((eq (car reference-element-cons) 'after)
                       (goto-char (org-element-property :end (cdr reference-element-cons)))))

                     ;; NOTE(nox): This is here to make the automatic "should insert blank" work better.
                     (when (org-at-heading-p) (backward-char))

                     (setq level (org-element-property :level (cdr reference-element-cons))))

                 (goto-char (or (org-element-map contents 'section
                                  (lambda (section) (org-element-property :end section))
                                  nil t org-element-all-elements)
                                (point-max))))

               (setq level (or level
                               (1+ (or (org-element-property :level ast) 0))))

               ;; NOTE(nox): This is needed to insert in the right place
               (unless (org-noter--no-heading-p) (outline-show-entry))
               (org-noter--insert-heading level title empty-lines-number location)
               ;; store the highlight in org IF we have a highlight AND can serialize it.
               (when-let ((highlight-location)
                          (serialized-highlight (org-noter--get-serialized-highlight highlight-location)))
                 (org-set-property "HIGHLIGHT" serialized-highlight))
               (when note-body
                 (save-excursion
                   (if short-selected-text
                       (insert "``" note-body "''")
                     (insert "#+BEGIN_QUOTE\n" note-body "\n#+END_QUOTE"))))
               (when (org-noter--session-hide-other session) (org-overview))

               (setf (org-noter--session-num-notes-in-view session)
                     (1+ (org-noter--session-num-notes-in-view session)))))

           (org-show-set-visibility t)
           (org-cycle-hide-drawers 'all)
           (org-cycle-show-empty-lines t)
           (when org-noter-highlight-selected-text ; return to DOC window and highlight text
             (select-frame-set-input-focus (org-noter--session-frame session))
             (select-window (get-buffer-window (org-noter--session-doc-buffer session)))
             (run-hook-with-args-until-success 'org-noter--add-highlight-hook major-mode highlight-location))))
       (when quit-flag
         ;; NOTE(nox): If this runs, it means the user quitted while creating a note, so
         ;; revert to the previous window.
         (select-frame-set-input-focus (org-noter--session-frame session))
         (select-window (get-buffer-window (org-noter--session-doc-buffer session))))))))

(defun org-copy-subtree-contents (&optional n cut force-store-markers nosubtrees)
  "Copy the current subtree into the clipboard.
With prefix arg N, copy this many sequential subtrees.
This is a short-hand for marking the subtree and then copying it.
If CUT is non-nil, actually cut the subtree.
If FORCE-STORE-MARKERS is non-nil, store the relative locations
of some markers in the region, even if CUT is non-nil.  This is
useful if the caller implements cut-and-paste as copy-then-paste-then-cut."
  (interactive "p")
  (org-preserve-local-variables
   (let (beg end folded (beg0 (point)))
     (if (called-interactively-p 'any)
	 (org-back-to-heading nil)    ; take what looks like a subtree
       (org-back-to-heading t))	      ; take what is really there
     ;; Do not consider inlinetasks as a subtree.
     (when (org-element-type-p (org-element-at-point) 'inlinetask)
       (org-up-element))
     (forward-line 5)
     (setq beg (point))
     ;; (setq beg (org-element-property :end (org-element-at-point)))

     (skip-chars-forward " \t\r\n")
     (save-match-data
       (if nosubtrees
	   (outline-next-heading)
	 (save-excursion (outline-end-of-heading)
			 (setq folded (org-invisible-p)))
	 (ignore-errors (org-forward-heading-same-level (1- n) t))
	 (org-end-of-subtree t t)))
     ;; Include the end of an inlinetask
     (when (and (featurep 'org-inlinetask)
		(looking-at-p (concat (org-inlinetask-outline-regexp)
				      "END[ \t]*$")))
       (end-of-line))
     (setq end (point))
     (goto-char beg0)
     (when (> end beg)
       (setq org-subtree-clip-folded folded)
       (when (or cut force-store-markers)
	 (org-save-markers-in-region beg end))
       (if cut (kill-region beg end) (copy-region-as-kill beg end))
       (setq org-subtree-clip (current-kill 0))
       (message "%s: Subtree(s) with %d characters"
		(if cut "Cut" "Copied")
		(length org-subtree-clip))))))

(defun org-noter-pdftools-embed-org-note-to-review ()
  "Embed a org subtree to its corresponding PDF annotation."
  (interactive)
  (org-noter--with-valid-session
   (unless (equal (selected-window) (org-noter--get-notes-window))
     (error "You should use this command in an org-noter note buffer"))
   (let* ((org-id (org-id-get)))
     (unless (and (string-match ".*\\(annot-.*-.*\\)" org-id)
                  org-noter-pdftools-use-org-id
                  org-noter-pdftools-use-pdftools-link-location)
       (error "This can only be run on an org heading with a valid org-pdftools annotation ID.
Please also make sure `org-noter-pdftools-use-org-id' and `org-noter-pdftools-use-pdftools-link-location' are enabled"))
     (let* ((annot-id (match-string 1 org-id))
            note)
       (setq kr kill-ring)
       (org-copy-subtree-contents nil nil nil t)
       (setq note (car kill-ring))
       (setq kill-ring kr)
       (with-selected-window
           (org-noter--get-doc-window)
         (let ((annot (pdf-annot-getannot (intern annot-id))))
           (with-current-buffer (pdf-annot-edit-contents-noselect annot)
             (insert note)
             (pdf-annot-edit-contents-finalize t)))
         ;; (save-buffer)
         )))))
(defun org-noter-pdftools-embed-all-org-notes-to-review ()
  (interactive)
  (org-noter--with-valid-session
   (with-selected-window (org-noter--get-notes-window)
     (save-excursion
       (org-map-entries #'org-noter-pdftools-embed-org-note-to-review "ID={annot-}")))))

  )
(use-package! org-pdftools
  :hook (org-load . org-pdftools-setup-link))

(use-package! org-noter-pdftools
  :after org-noter
  :config
  (with-eval-after-load 'pdf-annot
    (add-hook 'pdf-annot-activate-handler-functions #'org-noter-pdftools-jump-to-note)
    )
  )

#+end_src
* org-ref
#+begin_src emacs-lisp
(require 'org-ref)
(require 'org-ref-ivy)
(after! org-ref
    (setq bibtex-completion-notes-path "~/research/notes/references"
          org-ref-notes-function 'orb-edit-notes
          bibtex-completion-edit-notes-function #'orb-bibtex-completion-edit-note)
(define-key bibtex-mode-map (kbd "C-c C-c") 'org-ref-bibtex-hydra/body)
(define-key org-mode-map (kbd "C-c ]") 'org-ref-insert-link)

(setq org-ref-bibliography-entry-format
      '(
        ("article" . "%a, %t, <i>%j</i>, <b>%v(%n)</b>, %p (%y). <a href=\"%U\">link</a>. <a href=\"http://dx.doi.org/%D\">doi</a>.")
        ("book" . "%a, %t, %u (%y).")
        ("thesis" . "%a, %t, %s (%y).  <a href=\"%U\">link</a>. <a href=\"http://dx.doi.org/%D\">doi</a>.")
        ("misc" . "%a, %t (%y).  <a href=\"%U\">link</a>. <a href=\"http://dx.doi.org/%D\">doi</a>.")
        ("inbook" . "%a, %t, %b (pp. %p), %u (%y), <a href=\"%U\">link</a>. <a href=\"http://dx.doi.org/%D\">doi</a>.")
        ("techreport" . "%a, %t, %i, %u (%y).")
        ("proceedings" . "%e, %t in %S, %u (%y).")
        ("inproceedings" . "%a, %t, %p, in %b, edited by %e, %u (%y)"))
      )
)
#+end_src
* app
** rss
#+begin_src emacs-lisp
(map! :map doom-leader-map "n R" 'elfeed)
(setq rmh-elfeed-org-files (list "~/prive/Dropbox/org/elfeed.org"))
(after! elfeed

(defun accacio/elfeed-search-print-entry (entry)
  "Print ENTRY to the buffer."
  (let* ((date (elfeed-search-format-date (elfeed-entry-date entry)))
         (title (or (elfeed-meta entry :title) (elfeed-entry-title entry) ""))
         (title-faces (elfeed-search--faces (elfeed-entry-tags entry)))
         (feed (elfeed-entry-feed entry))
         (feed-title
          (when feed
            (or (elfeed-meta feed :title) (elfeed-feed-title feed))))
         (tags (mapcar #'symbol-name (elfeed-entry-tags entry)))
         (tags-str (mapconcat
                    (lambda (s) (propertize s 'face 'elfeed-search-tag-face))
                    tags ","))
         (title-width (- (window-width) 10 elfeed-search-trailing-width))
         (title-column (elfeed-format-column
                        title (elfeed-clamp
                               elfeed-search-title-min-width
                               title-width
                               elfeed-search-title-max-width)
                        :left))
         (feed-column (elfeed-format-column
                       feed-title (elfeed-clamp elfeed-goodies/feed-source-column-width
                                                elfeed-goodies/feed-source-column-width
                                                elfeed-goodies/feed-source-column-width)
                       :left)))


    (insert (propertize date 'face 'elfeed-search-date-face) " ")
    (insert (propertize title-column 'face title-faces 'kbd-help title) " ")
    (when feed-title
      (insert (propertize feed-column 'face 'elfeed-search-feed-face) " "))
    (when tags
      (insert "(" tags-str ")"))))


(setq elfeed-search-header-function #'elfeed-search--header
 ;; elfeed-search-print-entry-function #'elfeed-goodies/entry-line-draw
 elfeed-search-print-entry-function #'accacio/elfeed-search-print-entry
 elfeed-goodies/entry-pane-position 'bottom
 elfeed-goodies/entry-pane-size .4
 )



(defun elfeed-search-tag-all (&rest tags)
  "Apply TAG to all selected entries."
  (interactive (list (intern (read-from-minibuffer "Tag: "))))
  (let ((entries (elfeed-search-selected)))
    (cl-loop for tag in tags do (elfeed-tag entries tag))
    (mapc #'elfeed-search-update-entry entries)
    (unless (or elfeed-search-remain-on-entry (use-region-p))
      (forward-line))))

(defun elfeed-search-untag-all (&rest tags)
  "Remove TAG from all selected entries."
  (interactive (list (intern (read-from-minibuffer "Tag: "))))
  (let ((entries (elfeed-search-selected)))
    (cl-loop for value in tags do (elfeed-untag entries value))
    (mapc #'elfeed-search-update-entry entries)
    (unless (or elfeed-search-remain-on-entry (use-region-p))
      (forward-line))))

(defun elfeed-search-toggle-all ( &rest tags)
  "Toggle TAG on all selected entries."
  (interactive (list (intern (read-from-minibuffer "Tag: "))))
  (let ((entries (elfeed-search-selected)) entries-tag entries-untag)
    (cl-loop for tag in tags do
      (cl-loop for entry in entries
             when (elfeed-tagged-p tag entry)
             do (elfeed-untag-1 entry tag)
             else do (elfeed-tag-1 entry tag)))
    (mapc #'elfeed-search-update-entry entries)
    (unless (or elfeed-search-remain-on-entry (use-region-p))
      (forward-line))))

(evil-define-key 'normal elfeed-search-mode-map "i" (lambda () (interactive)(elfeed-search-toggle-all 'important 'readlater)))
(evil-define-key 'visual elfeed-search-mode-map "i" (lambda () (interactive)(elfeed-search-toggle-all 'important 'readlater)))
(evil-define-key 'normal elfeed-search-mode-map "t" (lambda () (interactive)(elfeed-search-toggle-all 'readlater)))
(evil-define-key 'visual elfeed-search-mode-map "t" (lambda () (interactive)(elfeed-search-toggle-all 'readlater)))
(evil-define-key 'visual elfeed-search-mode-map "i" (lambda () (interactive)(elfeed-search-toggle-all 'important )))

(evil-define-key 'normal elfeed-search-mode-map "I" (lambda () (interactive)(elfeed-search-set-filter "@1-week-ago +important ")))
(evil-define-key 'normal elfeed-search-mode-map "R" (lambda () (interactive)(elfeed-search-set-filter "@1-week-ago +readlater ")))

(evil-define-key 'normal elfeed-show-mode-map "U" 'elfeed-show-tag--unread)
(evil-define-key 'normal elfeed-show-mode-map "t" (elfeed-expose #'elfeed-show-tag 'readlater))
(evil-define-key 'normal elfeed-show-mode-map "i" (elfeed-expose #'elfeed-show-tag 'important))

(defun elfeed-search-show-entry (entry)
  "Display the currently selected item in a buffer."
  (interactive (list (elfeed-search-selected :ignore-region)))
  (require 'elfeed-show)
  (when (elfeed-entry-p entry)
    ;; (elfeed-untag entry 'unread)
    (elfeed-search-update-entry entry)
    ;; (unless elfeed-search-remain-on-entry (forward-line))
    (elfeed-show-entry entry)))

(defun accacio/elfeed-search-copy-article ()
  (interactive)
  (let ( (entries (elfeed-search-selected)) (links ""))
               (elfeed-search-untag-all 'readlater 'unread)
  (cl-loop for entry in entries
           when (elfeed-entry-link entry)
           do (progn (setq links (concat links (concat "- [ ] " (if (elfeed-tagged-p 'important entry) "* " "") (org-make-link-string  (concat "https://ezproxy.universite-paris-saclay.fr/login?url=" (elfeed-entry-link entry)) (elfeed-entry-title entry)) "\n" )))
               )
           )
  (kill-new links)
  )
  )
(setq-default elfeed-search-filter "@1-week-ago +unread")

(add-hook! 'elfeed-search-mode-hook 'elfeed-update)
(defface important-elfeed-entry
  '((t :foreground "#a00"))
  "Marks an control Elfeed entry.")
(defface control-elfeed-entry
  '((t :foreground "#2ba"))
  "Marks an control Elfeed entry.")

(defface readlater-elfeed-entry
  '((t :foreground "#Eec900"))
  "Marks a readlater Elfeed entry.")

(set-face-attribute 'elfeed-search-unread-title-face nil
                    :bold t :strike-through nil :underline nil :foreground "#bbb")

(set-face-attribute 'elfeed-search-title-face nil
                    :bold nil :strike-through t)

(push '(control control-elfeed-entry) elfeed-search-face-alist)
(push '(readlater readlater-elfeed-entry) elfeed-search-face-alist)
(push '(important important-elfeed-entry) elfeed-search-face-alist)

)

#+end_src
* Other functions
#+begin_src emacs-lisp
(defun accacio/find-straight-repos-file ()
  "Search for a file in `~/docsThese."
  (interactive)
  (dired "~/.emacs.d/.local/straight/repos/"))

(defun accacio/find-cfg-file ()
  "Search for a file in `~/.dots'."
  (interactive)
  (doom-project-find-file "~/.dots"))
(defun accacio/find-blog-post ()
  "Search for a file in `~/.dots'."
  (interactive)
  (doom-project-find-file "~/prive/site/content/blog"))
(map! :leader :prefix "f" "a" #'accacio/find-cfg-file)
(map! :leader :prefix "f" "b" #'accacio/find-blog-post)
#+end_src
* Trier
#+begin_src emacs-lisp
(add-hook 'LaTeX-mode-hook 'add-my-latex-environments)
(defun add-my-latex-environments ()
  (LaTeX-add-environments
   '("tikzpicture" LaTeX-env-label)
   '("frame" LaTeX-env-label)
   ))
#+end_src
