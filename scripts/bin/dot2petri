#!/bin/bash
set -o errexit -o pipefail -o nounset

version=0.0

function require {
    command -v $1 >/dev/null 2>&1 ||\
	{ echo >&2 "`basename $0`: $1 is a dependency and was not found. Aborting."; exit 1; }
}

function printError {
    echo >&2  $@
}

require dot2tex
require pdflatex

function usage {
    echo USAGE
}

function printd {
    if [ "$debug" == 1 ]
    then
	echo $@
    fi
}

# from https://stackoverflow.com/a/29754866/9781176
! getopt --test > /dev/null 
if [[ ${PIPESTATUS[0]} -ne 4 ]]; then
    echo 'I’m sorry, `getopt --test` failed in this environment.'
    exit 1
fi

OPTIONS=hto:dvp
LONGOPTS=debug,onlyTikzPicture,output:,verbose

# -use ! and PIPESTATUS to get exit code with errexit set
# -temporarily store output to be able to check for errors
# -activate quoting/enhanced mode (e.g. by writing out “--options”)
# -pass arguments only via   -- "$@"   to separate them correctly
! PARSED=$(getopt --options=$OPTIONS --longoptions=$LONGOPTS --name "`basename $0`" -- "$@")
if [[ ${PIPESTATUS[0]} -ne 0 ]]; then
    # e.g. return value is 1
    #  then getopt has complained about wrong arguments to stdout
    exit 2
fi

# read getopt’s output this way to handle the quoting right:
eval set -- "$PARSED"

outFile=""
onlyTikzPicture=0
exportPdf=0
debug=0 f=n v=n

# now enjoy the options in order and nicely split until we see --
while true; do
    case "$1" in
        -t|--onlyTikzPicture)
	    onlyTikzPicture=1
            shift
            ;;
	-d|--debug)
	    set -x
	    debug=1
	    shift
	    ;;
        -o|--output)
            outFile="$2"
	    exportPdf=1
            shift 2
            ;;
	-p)
	    exportPdf=1
	    shift
	    ;;
	-h)
	    usage
	    exit 0
	    ;;
	-v)
	    echo dot2petri version $version
	    exit 0
	    ;;
	--)
            shift
            break
            ;;
        *)
            usage
            exit 3
            ;;
    esac
done

# handle non-option arguments
if [[ $# -ne 1 ]]; then
    echo "`basename $0`: A single input file is required."
    usage
    exit 4
fi

# get stdin or file
if [ "$1" = "-"  ]
then
    if [ -p /dev/stdin ]
    then
	t="$(cat /dev/stdin)"
	inputFile="stdin"
    else
	echo "`basename $0`: Nothing in stdin"
	exit 4
    fi
else
    filename=$1
    fileext=${filename##*.}
    if [ ! $fileext = "dot" ]
    then
	echo "`basename $0`: File must be .dot"
	exit 4
    else
	if [ ! -f $filename ]
	then
	    echo "`basename $0`: $filename: No such file or directory"
	    exit 4
	fi
	t=`cat $1`
	fileext=${filename##*.}
	inputFile=$(basename $filename .$fileext)
    fi
fi

filenameTex="$inputFile.tex"
printd Filename: $filename
printd InputFile: $inputFile

if [ "$exportPdf" == 1 ]
then
    if [ "$outFile" = "" ]
    then
	outFile="$inputFile.pdf"
    else
	outfileext=${outFile##*.}
	if [ ! $outfileext = "pdf" ]
	then
	    echo "Output file must be .pdf"
	    exit 4
	fi
    fi
fi
printd Output File: $outFile

search_markedplace="\(\\\node (p\)\([0-9]\+\)\(m\)\([0-9]\+\)\() at (.*) \[draw,ellipse\)\(\] {};\)"
replace_markedplace="\\1\\2\\3\\4\\5,place, tokens=\\4, label=above:, label=left:\$p_{\\2}\$,rotate=90\\6"

search_place="\(\\\node (p\)\([0-9]\+\)\() at (.*) \[draw,ellipse\)\(\] {};\)"
replace_place="\\1\\2\\3,place, label=above:, label=left:\$p_{\\2}\$,rotate=90\\4"

search_timedtransition="\(\\\node (tt\)\([0-9]\+\)\() at (.*) \[draw,ellipse\)\(\] {};\)"
replace_timedtransition="\\1\\2\\3,timedtransition, label=above:, label=left:\$t_{\\2}\$,rotate=90\\4"

search_transition="\(\\\node (t\)\([0-9]\+\)\() at (.*) \[draw,ellipse\)\(\] {};\)"
replace_transition="\\1\\2\\3,transition, label=above:, label=left:\$t_{\\2}\$,rotate=90\\4"

if [ "$onlyTikzPicture" == 1 ]
then
    printd Only Tikz Picture
    if [ -f "$filenameTex" ]
    then
	echo "File $filename exists do you want to overwrite it? (y/N)"
	read p </dev/tty
	if [ "$p" = "y" ]
	then
	    printd removing $filename
	    rm $filename
	else
	    exit 1
	fi
    fi
    printd running dot2tex
    echo "$t" |sed -E "s/^([ ]*(p|t|tt)[0-9,m]+)$/\1 [label=\"\"]/g"\
	| dot2tex --prog dot --autosize -f tikz --figonly \
	| sed "s/$search_markedplace/$replace_markedplace/g"|\
	sed "s/$search_place/$replace_place/g"    |\
	sed "s/$search_transition/$replace_transition/g" |\
	sed "s/$search_timedtransition/$replace_timedtransition/g" \
	    > $filenameTex
    if [ ! -s "$filenameTex" ]
    then
	printError $filenameTex could not be written semantic error in $filename
	rm $filenameTex
	exit 1
    fi
else
    if [ -f "$filenameTex" ]
    then
	echo "File $filenameTex exists do you want to overwrite it? (y/N)"
	read p </dev/tty
	if [ "$p" = "y" ]
	then
	    printd removing $filenameTex
	    rm $filenameTex
	else	
	    exit 1
	fi
    fi
    printd running dot2tex
    ! echo "$t" |sed -E "s/^([ ]*(p|t|tt)[0-9,m]+)$/\1 [label=\"\"]/g"\
	| dot2tex --prog dot --autosize -f tikz \
		  --docpreamble \
		  "\usetikzlibrary{arrows,shapes,petri,external}
	\tikzexternalize
	\tikzsetnextfilename{figure}
	\tikzset{
	place/.style={
	circle,
	thick,
	draw=black!100, % draw=blue!75,
    % fill=blue!20,
    minimum size=6mm
  },
  extPlace/.style={
    circle,
    dotted,
    draw=black!100, % draw=blue!75,
    % fill=blue!20,
    minimum size=6mm
  },
  transition/.style={
    rectangle,
    thick,
    fill=black,
    minimum width=8mm,
    inner ysep=0.7pt
  },
  timedtransition/.style={
    rectangle,
    thick,
    fill=black,
    minimum width=8mm,
    inner ysep=2pt
  },
  inhibitor/.style={-o},
  text/.style={}
}" \
	| sed "s/$search_markedplace/$replace_markedplace/g"|\
	sed "s/$search_place/$replace_place/g"    |\
	sed "s/$search_transition/$replace_transition/g" |\
	sed "s/$search_timedtransition/$replace_timedtransition/g" \
	    > $filenameTex
    if [ ! -s "$filenameTex" ]
    then
	printError $filenameTex could not be written semantic error in $filename
	rm $filenameTex
	exit 1
    fi
fi




if [ "$onlyTikzPicture" == 0 -a  "$exportPdf" == 1 ]
then
    printd running pdflatex to generate pdf
    pdflatex --shell-escape --output-directory /tmp/ $filenameTex 2&>/dev/null
    [ -f "figure.pdf" ] && mv figure.pdf $outFile; rm figure.*
fi

tempfile=$(mktemp)
cat $filenameTex| awk '/% Start of code/{f=1;next} /% End of code/{f=0} f' > $tempfile
mv $tempfile "$filenameTex"
